Q1. State the main functions of the network layer.
The network layer (Layer 3) is responsible for:​

Logical addressing: Assigns unique IP addresses to devices, ensuring accurate identification and communication across networks

Routing: Determines the optimal path for packets to travel across multiple networks using routing algorithms and protocols

Packet forwarding: Moves packets from the input interface of a router to the appropriate output interface based on the destination IP

Fragmentation and reassembly: Splits large packets into smaller fragments to match the maximum transmission unit (MTU) of a network, and reassembles them at the destination

Error handling and diagnostics: Detects and reports network errors (e.g., via ICMP)

Packetization: Encapsulates transport layer segments into packets for efficient transmission

Q2. Differentiate between network layer and transport layer.
Feature	Network Layer	Transport Layer
OSI Layer	Layer 3	Layer 4
Main Focus	Host-to-host delivery via routing and logical addressing	Process-to-process delivery with reliability and flow control
Protocols	IP, ICMP, ARP, IGMP	TCP, UDP
Data Unit	Packet	Segment
Error Control	Limited - mainly diagnostics	Robust - checksums, retransmissions, acknowledgments
Delivery Guarantee	Best-effort, no guarantee	TCP: reliable; UDP: unreliable
Q3. Explain the concept of logical addressing.
Logical addressing refers to assigning software-based, globally unique identifiers (IP addresses) to each device on a network. Unlike physical addresses (MAC addresses) that are fixed on network interface cards and only work within a local network segment, logical addresses allow data to be routed across different networks, subnets, and even the entire internet independent of physical device locations.​

Example: IP address 192.168.1.5 uniquely identifies a device on the network regardless of its physical location.

Q4. What is the purpose of routing in the network layer?
Routing selects the best path for packets to travel from the source to the destination, possibly across multiple networks and routers. Routers examine destination IP addresses and consult routing tables to decide how and where to forward packets next, ensuring efficient delivery across interconnected networks.​

Q5. Define hop count and its importance.
Hop count is the number of intermediate devices (routers) a packet passes through from source to destination. It is used to measure route length and is crucial for:​

Loop prevention (prevents packets from circulating indefinitely)

Route optimization (shorter paths are preferred)

Routing protocol decisions (e.g., RIP uses hop count as its primary metric, with a maximum of 15 hops)

Q6. Explain the key functions of the network layer in the OSI model.
The key functions include:​

Logical addressing (IP addresses)

Routing (finding best paths)

Forwarding (moving packets between interfaces)

Fragmentation and reassembly (handling different network MTUs)

Error handling (via ICMP messages)

Congestion management and traffic control

Q7. Describe how the network layer ensures packet forwarding and routing between networks.
The network layer examines the destination IP address in each packet header and consults routing tables to determine the next hop. Each router looks up the destination IP, finds the matching entry in its routing table, and forwards the packet to the appropriate outgoing interface. This hop-by-hop forwarding continues until the packet reaches its final destination.​

Q8. Discuss the role of congestion control and error handling in the network layer.
Congestion Control: At the network layer, congestion is managed through buffer management, queue management policies, and in some protocols, source quench messages that signal overloaded routers to slow transmission.​

Error Handling: ICMP (Internet Control Message Protocol) handles errors by reporting issues such as unreachable destinations, timeout, parameter problems, and redirections back to the source host. However, error control at the network layer is limited compared to the transport layer; most reliability mechanisms are implemented at higher layers (TCP).

SECTION 2: SWITCHING TECHNIQUES
Q9. Define switching.
Switching is the technique of directing data from one device to another across a network using devices called switches. It determines how information flows through the network and reaches its intended destination.​

Q10. List the types of switching techniques used in networking.
There are three main types of switching techniques:​

Circuit switching: Establishes a dedicated communication path before data transmission

Message switching: Stores and forwards entire messages at intermediate switches

Packet switching: Divides messages into packets and routes them individually

Q11. What is circuit switching? Give one example.
Circuit switching is a communication method where a dedicated communication path, or circuit, is established between two devices before data transmission begins. The circuit remains dedicated to the communication for the entire duration of the session, and no other devices can use it during this time.​

Example: Traditional telephone networks use circuit switching. When you call someone, a dedicated circuit is established from your phone through the switching office to the recipient's phone for the entire duration of the call.

Q12. Define message switching and its major drawback.
Message switching is a method where whole messages (not broken into smaller units) are stored and forwarded at each intermediate switch (store-and-forward technique).​

Major drawbacks:

High delay: Messages must be completely received and stored at each intermediate switch before being forwarded

Large memory requirements: Intermediate switches need sufficient storage to hold entire messages

Not suitable for real-time communication: Due to accumulating delays across multiple hops

Q13. What is packet switching?
Packet switching is a communication method where messages are divided into smaller units called packets, which are individually routed through the network. Each packet contains source and destination address information and may take different paths through the network. The recipient reassembles packets in the correct order to reconstruct the original message.​

Q14. Compare and contrast circuit switching, message switching, and packet switching.
Characteristic	Circuit Switching	Message Switching	Packet Switching
Path	Reserved, fixed for entire call	No reservation, entire message follows one path	No fixed path, each packet may differ
Latency/Delay	Consistent, low	Variable, potentially very high	Variable, generally moderate
Resource Utilization	Inefficient (bandwidth wasted during silence)	Moderate	Highly efficient (bandwidth shared)
Bandwidth Guarantee	Yes, dedicated	No	No
Example Use	Telephone networks	Telegraph systems	Internet (IP networks)
Reliability	Highly reliable	Reliable	Moderate (packet loss possible)
Suitable for Real-time	Yes	No	Limited (without QoS)
Store-and-Forward	No	Yes	Yes
Packet/Message Ordering	N/A	N/A	May arrive out of order
Q15. Explain in detail the working of packet switching with a neat diagram.
Working Process:

Division: The original message from the source is divided into multiple small packets

Labeling: Each packet receives a header containing:

Source IP address

Destination IP address

Packet sequence number

Data length and other control information

Independent Routing: Each packet is sent independently through the network; routers use routing tables to determine the best path for each packet

Multiple Paths: Different packets from the same message may traverse different paths through the network

Reception and Reassembly: At the destination, packets arrive (possibly out of order or with delays) and are reassembled using sequence numbers

Diagram Reference: [See typical textbook diagrams showing packet flow through multiple routers with different paths converging at destination]

Advantage: Network resources are used efficiently since bandwidth is shared among multiple communications.

Q16. Advantages and disadvantages of each switching technique.
Circuit Switching:

Advantages: Low latency, predictable performance, guaranteed bandwidth, suitable for real-time communication

Disadvantages: Inefficient bandwidth use, limited scalability, high cost, requires call setup time

Message Switching:

Advantages: Reliable delivery, flexible scheduling, reduced bandwidth needs

Disadvantages: High delay, requires large memory, not suitable for real-time applications, slow

Packet Switching:

Advantages: Efficient bandwidth utilization, highly scalable, lower cost, supports diverse data rates, robust to network failures

Disadvantages: Higher latency than circuit switching, potential packet loss, packets may arrive out of order, limited QoS guarantees, not ideal for real-time communication without QoS mechanisms

Q17. Differentiate between virtual circuit and datagram packet switching.
Feature	Virtual Circuit	Datagram
Connection	Connection-oriented	Connectionless
Path Establishment	Path established before data transfer (3-phase: setup, transfer, teardown)	No path setup required
Packet Routing	All packets follow the same path	Each packet routed independently
Packet Ordering	Packets arrive in order	Packets may arrive out of order
Reliability	More reliable (guaranteed path)	Less reliable (may lose packets)
Speed	Slower (requires setup phase)	Faster (no setup overhead)
Implementation	ATM, Frame Relay, X.25	IP (Internet Protocol), datagram-based networks
Overhead	Higher (due to setup)	Lower
Header Complexity	Simple (uses virtual circuit ID)	More complex (full addressing in each packet)
SECTION 3: IP ADDRESSING
Q18. What is IP addressing?
IP addressing is a system that assigns unique software-based identifiers (addresses) to every device connected to the internet or a computer network. IP addresses enable devices to communicate with each other across networks by providing a standardized way to identify and route data to the correct destination.​

Q19. Define and differentiate between IPv4 and IPv6.
IPv4 (Internet Protocol Version 4):

32-bit address space (approximately 4.3 billion addresses)

Dotted decimal notation: 192.168.1.1

Classes: A, B, C, D, E

Addressing scheme exhausted; NAT used as workaround

Simpler header but more overhead

IPv6 (Internet Protocol Version 6):

128-bit address space (340 undecillion addresses - effectively unlimited)

Hexadecimal notation: 2001:0db8:85a3:0000:0000:8a2e:0370:7334

No classes; uses prefix-based addressing

Built-in security (IPSec)

Simplified header, improved routing

Better support for quality of service and multicast

Feature	IPv4	IPv6
Address Length	32 bits	128 bits
Address Space	~4.3 billion	~340 undecillion
Address Format	Decimal (xxx.xxx.xxx.xxx)	Hexadecimal (xxxx:xxxx:xxxx:xxxx...)
Header Size	20 bytes minimum	40 bytes fixed
Security	Optional (IPSec can be added)	Mandatory (IPSec built-in)
Address Classes	Yes (A, B, C, D, E)	No (uses CIDR)
Q20. What is Network Address Translation (NAT)?
Network Address Translation is a technique that maps private IP addresses used within a private network to public IP addresses for internet communication. NAT allows multiple devices on a private network to share a single public IP address, thereby conserving the limited IPv4 address space and adding a layer of security by hiding internal network structure.​

Q21. Explain the concept of subnet mask.
A subnet mask is a 32-bit number (in IPv4) that separates the network portion of an IP address from the host portion. It is written in dotted decimal notation (e.g., 255.255.255.0) and uses consecutive 1s followed by consecutive 0s. The 1s indicate the network bits, and the 0s indicate the host bits.​

Example: In 192.168.1.5 with mask 255.255.255.0:

Network portion: 192.168.1.0

Host portion: .5

Q22. What is CIDR? How does it differ from traditional class-based addressing?
CIDR (Classless Inter-Domain Routing) is a modern addressing method that eliminates the fixed class structure (A, B, C, D, E) and instead uses a prefix notation to specify the number of network bits.​

CIDR Notation: 192.168.1.0/24 (the /24 means first 24 bits are network, last 8 bits are host)

Differences from Classful Addressing:

Aspect	Classful	CIDR
Structure	Fixed classes (A, B, C)	Variable-length prefix
Flexibility	Fixed host/network division per class	Customizable network size
Address Efficiency	Wasteful (many unused addresses)	Efficient (minimizes waste)
Notation	IP address alone (e.g., 192.168.1.1)	IP/prefix length (e.g., 192.168.1.0/24)
VLSM Support	No	Yes (Variable Length Subnet Mask)
Routing	Class-based	Prefix-based
Adopted	1981-1993	1993-present
Q23. Explain the different classes of IP addresses (A, B, C, D, E) with range and examples.
Class A:​

Range: 1.0.0.0 to 126.255.255.255

First Octet: 0xxxxxxx (starts with 0)

Network Bits: 8 bits

Host Bits: 24 bits

Networks: 127 (2^7 - 1)

Hosts per Network: 16,777,214 (2^24 - 2)

Default Subnet Mask: 255.0.0.0

Example: 10.0.0.1, 50.25.30.40

Class B:

Range: 128.0.0.0 to 191.255.255.255

First Octet: 10xxxxxx (starts with 10)

Network Bits: 16 bits

Host Bits: 16 bits

Networks: 16,384 (2^14)

Hosts per Network: 65,534 (2^16 - 2)

Default Subnet Mask: 255.255.0.0

Example: 172.16.0.1, 150.100.50.30

Class C:

Range: 192.0.0.0 to 223.255.255.255

First Octet: 110xxxxx (starts with 110)

Network Bits: 24 bits

Host Bits: 8 bits

Networks: 2,097,152 (2^21)

Hosts per Network: 254 (2^8 - 2)

Default Subnet Mask: 255.255.255.0

Example: 192.168.1.1, 200.50.100.25

Class D (Multicast):

Range: 224.0.0.0 to 239.255.255.255

First Octet: 1110xxxx (starts with 1110)

Purpose: Multicast communication

No Subnet Mask

Example: 224.0.0.1 (all hosts multicast)

Class E (Experimental):

Range: 240.0.0.0 to 255.255.255.255

First Octet: 1111xxxx (starts with 1111)

Purpose: Reserved for experimental and research use

No Subnet Mask

Not Used for regular communication

Note: Network ID with all 0s represents the network itself; Host ID with all 1s represents broadcast address (not assigned to devices).

Q24. Discuss in detail IPv4 header format with a neat diagram.
IPv4 Header Fields (20 bytes minimum):​

Version (4 bits): Identifies IP version (4 for IPv4)

Header Length (4 bits): Specifies header length in 32-bit words (minimum 5 = 20 bytes)

Type of Service/ToS (8 bits): Specifies quality of service and priority

Total Length (16 bits): Total length of packet (header + data) in bytes

Identification (16 bits): Unique identifier for this packet for fragmentation reassembly

Flags (3 bits):

Reserved (1 bit)

Don't Fragment (DF)

More Fragments (MF)

Fragment Offset (13 bits): Position of this fragment relative to original datagram (in 8-byte units)

Time to Live/TTL (8 bits): Decremented by 1 at each router; packet discarded when TTL reaches 0 (prevents routing loops)

Protocol (8 bits): Identifies protocol in payload (6 = TCP, 17 = UDP, 1 = ICMP, etc.)

Header Checksum (16 bits): Checksum of header only (recalculated at each hop)

Source IP Address (32 bits): IP address of sending device

Destination IP Address (32 bits): IP address of receiving device

Options (variable): Optional fields (if Header Length > 5); includes padding to 32-bit boundary

IPv4 Header Diagram:

text
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version|  IHL  |Type of Service|          Total Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Identification        |Flags|      Fragment Offset     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Time to Live |    Protocol   |         Header Checksum        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Source Address                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Destination Address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options (if IHL > 5)                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Data (Payload)                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
Q25. Explain IPv6 addressing structure and header format.
IPv6 Address Structure:

IPv6 uses 128-bit addresses written in hexadecimal notation with colons separating 16-bit groups. Example: 2001:0db8:85a3:0000:0000:8a2e:0370:7334

Address Types:

Unicast: One-to-one communication to a single device

Multicast: One-to-many communication

Anycast: Delivery to the nearest device in a group

IPv6 Header Format (40 bytes fixed):​

Version (4 bits): IP version (6 for IPv6)

Traffic Class (8 bits): Similar to ToS in IPv4; identifies priority/QoS

Flow Label (20 bits): Identifies flow of packets requiring special handling

Payload Length (16 bits): Length of data portion (not including header)

Next Header (8 bits): Identifies type of next header (TCP, UDP, ICMP, etc.) or extension header

Hop Limit (8 bits): Similar to TTL in IPv4; decremented at each hop

Source Address (128 bits): IPv6 address of sender

Destination Address (128 bits): IPv6 address of recipient

Key IPv6 Improvements:

Simplified header (no fragmentation at intermediate routers)

Built-in IPSec security

Better multicast support

Automatic address configuration

Larger address space eliminates NAT necessity

Q26. Describe NAT and its types (Static, Dynamic, PAT) with examples.
NAT (Network Address Translation) is a technique that modifies network address information in packet headers while in transit, allowing devices on a private network to communicate with external networks using a single public IP address.​

Types of NAT:

1. Static NAT:

Maps private IP to specific public IP on one-to-one basis

Permanent mapping; same private address always maps to same public address

Example: Private 192.168.1.10 → Always maps to Public 203.0.113.5

Use Case: Web servers that need consistent public addresses

2. Dynamic NAT:

Maps private IPs to pool of public IPs dynamically

Assignment is temporary; may change with each session

Example:

Private 192.168.1.10 → Public 203.0.113.5 (session 1)

Private 192.168.1.10 → Public 203.0.113.6 (session 2)

Use Case: Large organizations with many clients

3. PAT (Port Address Translation) - Also called Many-to-One or Overloading NAT:**

Maps many private IPs to single public IP using different port numbers

Conserves public IP addresses most effectively

Example:

192.168.1.10:1234 → 203.0.113.5:5000

192.168.1.11:1235 → 203.0.113.5:5001

192.168.1.12:1236 → 203.0.113.5:5002

Use Case: Home/small office routers (most common)

Comparison Table:

Feature	Static NAT	Dynamic NAT	PAT
Mapping	One-to-one, permanent	One-to-one, temporary	Many-to-one
Public IPs Needed	Multiple	Multiple	One or few
Complexity	Simple	Moderate	Moderate
Cost	Higher	Higher	Lower
Use Case	Servers, Web hosts	Organizations	Home users, small networks
SECTION 4: NETWORK PROTOCOLS
Q28. What is ARP and why is it used?
ARP (Address Resolution Protocol) is used to map IP addresses (logical addresses) to MAC addresses (physical addresses).​

Why it's used:

Devices need MAC addresses to communicate on the same physical network (LAN)

IP addresses work across networks, but within a LAN, the Data Link Layer requires MAC addresses

ARP bridges the gap between Layer 3 (IP) and Layer 2 (Ethernet)

Q29. Differentiate between ARP and RARP.
Feature	ARP	RARP
Purpose	Map IP address to MAC address	Map MAC address to IP address
Direction	IP → MAC (forward)	MAC → IP (reverse)
Use Case	Find MAC of device with known IP	Find IP when only MAC is known
Example Scenario	"Who has IP 192.168.1.5?"	"What is my IP address?" (diskless workstations)
Response Type	Unicast reply	Sent to RARP server
Common	Very common	Rarely used (replaced by DHCP)
Q30. Define ICMP and its main functions.
ICMP (Internet Control Message Protocol) is a network protocol used for sending error messages and diagnostic information about network conditions.​

Main Functions:

Error Reporting: Reports unreachable hosts/networks, packet too large, time exceeded

Diagnostics: Ping and Traceroute utilities rely on ICMP

Congestion Control: Source Quench messages signal congestion

Redirection: Informs hosts of better routes

Parameter Problem: Reports invalid header parameters

Q31. What is IGMP?
IGMP (Internet Group Management Protocol) is a protocol used to manage multicast group memberships in IP networks. It allows hosts to join and leave multicast groups and enables routers to learn which multicast groups have active members on their networks.​

Q32. State the message types used in ICMP.
Common ICMP Message Types:​

Echo Request (Type 8): Ping request

Echo Reply (Type 0): Ping response

Destination Unreachable (Type 3): Host/network/port unreachable

Time Exceeded (Type 11): TTL reached 0 or reassembly timeout

Redirect (Type 5): Route optimization messages

Parameter Problem (Type 12): Invalid header parameter

Timestamp Request/Reply (Type 13/14): Time synchronization

Source Quench (Type 4): Congestion control (deprecated)

Router Advertisement (Type 9): Router availability

Router Solicitation (Type 10): Request router information

Q33. Explain the working of ARP and RARP with example scenarios.
ARP Working Example:

Device A (192.168.1.10) wants to send data to Device B (192.168.1.20) on the same LAN:

Device A checks its ARP cache for IP 192.168.1.20

Not found, so Device A broadcasts ARP Request: "Who has IP 192.168.1.20?"

All devices on LAN receive the request

Device B recognizes its own IP and responds: "I have 192.168.1.20, my MAC is AA:BB:CC:DD:EE:FF"

Device A receives ARP Reply, updates ARP cache with mapping: 192.168.1.20 ↔ AA:BB:CC:DD:EE:FF

Device A can now send frames to Device B using the MAC address

RARP Working Example:

Diskless workstation boots and needs to find its own IP address:

Workstation broadcasts RARP Request containing its MAC address: "What is my IP?"

RARP server on the network receives the request

RARP server looks up the MAC address in its database

Server responds: "Your MAC matches IP 192.168.1.50"

Workstation configures itself with this IP address

(Note: RARP is now obsolete; DHCP performs this function more efficiently)

Q34. Describe the role of ICMP in IP networking.
ICMP provides essential diagnostic and error-reporting capabilities:​

Error Notification: When packets cannot reach destination, the router sends ICMP error messages back to sender

Path Discovery: Traceroute command uses ICMP TTL exceeded messages to discover the path packets take

Reachability Testing: Ping utility (uses ICMP Echo Request/Reply) verifies if hosts are reachable

Network Monitoring: Administrators use ICMP-based tools for network troubleshooting

Congestion Signaling: ICMP Source Quench (deprecated) alerts sources to reduce transmission rate

Host Unreachable Notification: Reports when destination hosts are unreachable

Q35. Discuss IGMP and its importance in multicast communication.
IGMP enables efficient multicast communication:​

Membership Reporting: Hosts inform routers when they want to join a multicast group

Membership Queries: Routers periodically query hosts to determine which multicast groups are active

Leave Notification: Hosts signal when leaving a multicast group

Multicast Routing: Routers use IGMP information to build multicast distribution trees

Importance in Multicast:

Without IGMP, routers would have to flood multicast packets to all ports (inefficient)

IGMP allows routers to only forward multicast traffic on ports with active group members

Enables efficient video streaming, online gaming, stock price updates, and other one-to-many applications

Q36. Compare ARP, RARP, ICMP, and IGMP protocols based on their functionality.
Protocol	Purpose	Layer	Message Type	Response	Use Case
ARP	Map IP to MAC	2.5/3	Request/Reply	Unicast reply	Find MAC of known IP
RARP	Map MAC to IP	2.5/3	Request/Reply	Reply from server	Diskless boot (obsolete)
ICMP	Error/diagnostics	3	Various (8 types)	Echo reply, errors	Ping, traceroute, errors
IGMP	Multicast management	3	Query/Report/Leave	Membership reports	Multicast group management
SECTION 5: ROUTING FUNDAMENTALS
Q37. Define routing.
Routing is the process of selecting an optimal path for packets to travel from source to destination across a network or internetwork. Routers use routing algorithms and routing tables to make forwarding decisions based on destination addresses.​

Q38. Differentiate between static and dynamic routing.
Feature	Static Routing	Dynamic Routing
Configuration	Manually configured by administrator	Automatically learned by routing protocols
Flexibility	Low; changes require manual intervention	High; adapts automatically to network changes
Adaptation	Does not adapt to network changes	Adapts to link failures and topology changes
Overhead	Low (no protocol overhead)	Higher (protocol packets exchanged)
Scalability	Suitable for small networks only	Suitable for large, complex networks
Implementation	Simple (static routes in routing table)	Complex (requires routing protocol)
Convergence Time	Infinite (requires manual fix)	Seconds to minutes (protocol convergence)
Example Use Case	Small office, single network segment	ISPs, large enterprises, internet backbone
Bandwidth	None used by routing protocol	Uses bandwidth for protocol messages
CPU Load	Low	Higher
Q39. What is the purpose of routing algorithms?
Routing algorithms determine the best path for packets based on various metrics:​

Shortest Path Selection: Find routes with minimum hop count, latency, or cost

Efficiency: Distribute traffic across multiple paths

Reliability: Avoid failed links and find alternative routes

Load Balancing: Distribute traffic across multiple links

Convergence: Find equilibrium when network topology changes

Scalability: Work efficiently in large networks

Q40. Define distance vector routing.
Distance vector routing is an algorithm where each router maintains a vector (table) of distances to destination networks. Each entry contains the distance (metric) and the direction (next hop router) to reach that destination. Routers share their routing tables with neighbors periodically.​

Key Characteristic: Each router knows the direction and distance to reach networks but doesn't know the complete network topology.

Q41. What is a link-state routing algorithm?
Link-state routing is an algorithm where each router maintains complete knowledge of the network topology. Routers advertise the state of their directly connected links to all other routers, allowing every router to build a complete map of the network and calculate shortest paths independently.​

Key Characteristic: Each router knows the complete topology and calculates shortest paths using algorithms like Dijkstra's.

Q42. Explain static routing and dynamic routing with examples.
Static Routing Example:

Administrator manually enters routes:

text
Destination: 192.168.2.0/24 → Via Router B (next hop: 10.0.0.2)
Destination: 192.168.3.0/24 → Via Router C (next hop: 10.0.0.3)
Advantages: No overhead, predictable, secure
Disadvantages: No fault tolerance, manual maintenance required

Dynamic Routing Example:

Router A learns routes automatically:

Router A receives routing advertisements from neighbors

Neighbors announce their networks

Router A builds routing table dynamically

If a link fails, routers converge to new routes automatically

Advantages: Automatic adaptation, fault tolerance
Disadvantages: Overhead, processing power required

Q43. Describe Distance Vector Routing Algorithm and Count-to-Infinity problem.
Distance Vector Algorithm Basics:​

Each router initializes its routing table with directly connected networks

Each router periodically broadcasts its entire routing table to neighbors

Neighbors receive updates and add 1 (hop count) to all distances

If a shorter path is found, the routing table is updated

Process continues until convergence

Count-to-Infinity Problem:

This is a major limitation of distance vector routing:

Scenario: Network link fails

Router A originally knew: "Network X is 1 hop away via Router B"

Router B also knew: "Network X is directly connected"

When link to Network X fails, B marks it as unreachable (metric = 16, "infinity" in RIP)

Router A doesn't receive B's update immediately

Router A still thinks: "Network X is 1 hop away via B"

Router A advertises to B: "Network X is 1 hop away"

Router B updates: "Network X is 2 hops away via A"

This back-and-forth continues, slowly incrementing metrics (3, 4, 5...) until reaching "infinity"

This causes slow convergence and temporary routing loops

Solutions:

Maximum Hop Count: Set infinity to 15 (RIP); routes with 16+ hops are unreachable

Split Horizon: Don't advertise routes back through the interface they came from

Route Poisoning: Immediately announce infinite distance for failed routes

Hold-Down Timers: Ignore updates for a period after route failure

Q44. Explain the Link State Routing Algorithm with steps.
Link State Routing Algorithm Steps:​

Flood Link State Information: Each router sends "Hello" packets to neighbors to discover adjacent routers

Build Link State Database: Each router creates a database of all network links and their states (up/down)

Flood Link State Advertisements: Each router floods its link state information to all other routers in the network

Build Complete Topology: Each router receives link state info from all others and builds a complete network topology map

Run Dijkstra's Algorithm: Each router independently runs Dijkstra's algorithm to calculate shortest paths to all destinations

Update Routing Table: Based on calculated shortest paths, update the routing table

Monitor for Changes: Continuously monitor link states; if a change is detected, repeat the process

Advantages:

Fast convergence

No count-to-infinity problem

Complete topology knowledge

Better for large networks

Disadvantages:

Higher memory requirements

Higher CPU usage

More complex implementation

More bandwidth for link state advertisements

Q45. Compare Distance Vector, Link State, and Path Vector routing approaches.
Aspect	Distance Vector	Link State	Path Vector
Topology Knowledge	Partial (next hop direction)	Complete (entire topology)	Complete (AS path info)
Algorithm	Bellman-Ford	Dijkstra	Policies and AS path
Update Method	Full table, periodic	Link changes, flooding	Policy-based, event-driven
Convergence Time	Slow (count-to-infinity risk)	Fast	Very fast
Memory Use	Low	High	High
CPU Use	Low	High	Moderate
Scalability	Limited (max 15 hops)	Good	Excellent (inter-domain)
Loop Prevention	Split horizon, poison reverse	SPF calculation	AS path vectors
Example Protocols	RIP, IGRP	OSPF, IS-IS	BGP
Best For	Small networks	Large internal networks	Inter-domain (Internet)
Q46. Explain Dijkstra's Algorithm for shortest path calculation with an example.
Dijkstra's Algorithm Overview:

Dijkstra's algorithm finds the shortest path from a source node to all other nodes in a weighted graph with non-negative weights.​

Algorithm Steps:

Initialize: Set distance to source = 0, all others = ∞

Mark all nodes as unvisited

While there are unvisited nodes:

Select the unvisited node with smallest distance (current node)

For each neighbor of current node:

Calculate tentative distance: distance[neighbor] = distance[current] + weight[edge]

If this is less than the known distance to neighbor, update it

Mark current node as visited

Return the distances and paths

Practical Example:

Network graph:

text
       A --4-- B
       |       |
       8       6
       |       |
       C --2-- D --10-- E
       |
      5
       |
       F
Finding shortest paths from A to all nodes:

Initial State:

Distance: A=0, B=∞, C=∞, D=∞, E=∞, F=∞

Unvisited: {A, B, C, D, E, F}

Step 1 - Current: A (smallest distance = 0)

Update B: 0 + 4 = 4 ✓

Update C: 0 + 8 = 8 ✓

Visited: {A}

Distance: A=0, B=4, C=8, D=∞, E=∞, F=∞

Step 2 - Current: B (smallest unvisited = 4)

Update D: 4 + 6 = 10 ✓

Visited: {A, B}

Distance: A=0, B=4, C=8, D=10, E=∞, F=∞

Step 3 - Current: C (smallest unvisited = 8)

Update D: 8 + 2 = 10 (not better) ✗

Update F: 8 + 5 = 13 ✓

Visited: {A, B, C}

Distance: A=0, B=4, C=8, D=10, E=∞, F=13

Step 4 - Current: D (smallest unvisited = 10)

Update E: 10 + 10 = 20 ✓

Visited: {A, B, C, D}

Distance: A=0, B=4, C=8, D=10, E=20, F=13

Step 5 - Current: F (smallest unvisited = 13)

No neighbors to update

Visited: {A, B, C, D, F}

Distance: A=0, B=4, C=8, D=10, E=20, F=13

Step 6 - Current: E (smallest unvisited = 20)

No unvisited neighbors

Visited: All nodes

Final Result - Shortest paths from A:

A to B: 4 (via A→B)

A to C: 8 (via A→C)

A to D: 10 (via A→B→D or A→C→D)

A to E: 20 (via A→B→D→E)

A to F: 13 (via A→C→F)

Time Complexity: O(V² + E) or O((V + E) log V) with min-heap

SECTION 6: ROUTING PROTOCOLS
Q47. List types of routing protocols.
Routing protocols are classified as:

By Scope:

IGP (Interior Gateway Protocols) - Within Autonomous Systems:

RIP (Routing Information Protocol)

OSPF (Open Shortest Path First)

EIGRP (Enhanced IGRP)

IS-IS (Intermediate System to Intermediate System)

EGP (Exterior Gateway Protocols) - Between Autonomous Systems:

BGP (Border Gateway Protocol)

By Algorithm:

Distance Vector: RIP

Link State: OSPF, IS-IS

Path Vector: BGP

Hybrid: EIGRP

Q48. What is RIP and what metric does it use?
RIP (Routing Information Protocol) is one of the oldest distance-vector routing protocols used for routing within autonomous systems.​

Metric: Hop count (number of routers)

Maximum hop count: 15 (networks with 16+ hops considered unreachable)

Simple metric doesn't account for link speed or quality

Versions:

RIPv1: Classful routing, broadcasts entire routing table every 90 seconds

RIPv2: Classless routing, supports VLSM, more efficient updates

Characteristics:

Low memory and CPU requirements

Simple to implement and configure

Slow convergence time

Subject to count-to-infinity problem

Best for small networks only

Q49. Define OSPF and its advantages.
OSPF (Open Shortest Path First) is a link-state routing protocol designed for large networks.​

Advantages:

Fast Convergence: Quickly adapts to topology changes

No Count-to-Infinity: Uses complete topology knowledge

Hierarchical Design: Supports area hierarchy (backbone + areas)

Efficient: Uses incremental updates (floods only changes)

Load Balancing: Supports multiple equal-cost paths

Security: Supports authentication of routing messages

Scalability: Suitable for large, complex networks

Standards-Based: Open standard (not proprietary)

VLSM Support: Supports Variable Length Subnet Masks

Disadvantages:

Higher CPU and memory requirements

More complex configuration

Longer routing table entries

Requires more bandwidth for initial convergence

Q50. What is BGP and where is it used?
BGP (Border Gateway Protocol) is an exterior gateway protocol used to route traffic between different autonomous systems on the internet.​

Key Features:

Path vector algorithm (considers complete AS path, not just hop count)

Uses TCP for reliable communication (port 179)

Makes routing decisions based on policies and AS paths

Prevents routing loops by checking if own AS is already in path

Supports CIDR

Where it's used:

Internet backbone (ISP-to-ISP routing)

Large enterprise networks with multiple internet connections

Connecting different autonomous systems

Multi-homed networks requiring redundancy

Types:

iBGP: Between routers within same AS

eBGP: Between routers in different ASes

Q51. Define MPLS and its main benefit.
MPLS (Multiprotocol Label Switching) is a forwarding mechanism that uses short path labels instead of long IP addresses for faster packet forwarding.​

How it works:

Edge routers assign labels to incoming packets

Core routers forward based on labels (not IP lookup)

Labels determine both path and QoS treatment

Labels removed at egress edge router

Main Benefits:

Faster Forwarding: Label lookup faster than IP lookup

QoS Support: Labels can include QoS information for Traffic Engineering

Traffic Engineering: Explicit path control across network

VPN Support: Creates VPN tunnels via Label Switched Paths (LSPs)

Protocol Independent: Works with any Layer 3 protocol

Reduced Processing: Simpler than traditional IP routing

Q52. Explain the working of RIP (Routing Information Protocol) with advantages and limitations.
RIP Working:​

Each router maintains a routing table with distance to each known network

Every 30 seconds (RIPv1) or when topology changes, routers broadcast entire routing table to directly connected neighbors

Neighbors receive update, add 1 to all hop counts (hop count metric), and update their tables

If a new or shorter path is found, routing table is updated

Routes not updated within 180 seconds are marked as unreachable

Advantages:

Simple to implement and understand

Low memory and processing requirements

Works across different vendors

Suitable for small networks

Limitations:

Slow convergence (takes time to detect link failures)

Periodic updates waste bandwidth

Subject to count-to-infinity problem

Limited to 15-hop maximum (scales poorly)

Doesn't consider link quality, only hop count

Deprecated in modern networks

Q53. Describe OSPF (Open Shortest Path First) and its key features.
OSPF Working:​

Routers discover neighbors by sending "Hello" packets

Each router floods Link State Advertisements (LSAs) describing its directly connected links to all other routers

Every router builds identical Link State Database (LSDB) of network topology

Each router independently runs Dijkstra's algorithm to calculate shortest paths

Routers monitor for topology changes; when changes occur, only affected LSAs are flooded

Key Features:

Link-State Algorithm: Complete topology knowledge

Hierarchical Architecture: Backbone area (0) + normal areas

Fast Convergence: Seconds to minutes

Load Balancing: Equal-cost multi-path (ECMP)

Authentication: MD5 authentication for security

VLSM and CIDR: Supports flexible subnetting

Incremental Updates: Only topology changes trigger updates

TTL-based Loop Prevention: Uses IP TTL for loop prevention

Area Optimization: Areas reduce protocol overhead

Components:

Router ID: Unique identifier for each router

Neighbors: Directly connected routers

Hello packets: Discover and maintain neighbor relationships

LSAs: Advertisement of link states

LSDB: Database of all LSAs

SPF algorithm: Dijkstra's shortest path first

Q54. Explain BGP (Border Gateway Protocol) and how it supports inter-domain routing.
BGP Working:​

BGP routers establish TCP connections (port 179) with neighbor BGP routers

Routers exchange BGP advertisements containing path information

Each BGP update includes AS PATH (sequence of AS numbers traversed)

Routers make routing decisions based on policies and AS paths

AS PATH prevents loops: if own AS is in path, packet is dropped

How BGP Supports Inter-Domain Routing:

Autonomous System Awareness: Understands network organized as multiple ASes

Policy-Based: Routing decisions include business policies (not just metrics)

Complex Decisions: Considers multiple attributes:

AS Path length

Local preference

Multi-exit discriminator (MED)

Communities

Origin type

Weight

Scalability: Efficiently handles thousands of routes from different ISPs

Loop Prevention: AS Path prevents routing loops

Convergence: Event-driven updates (only sends changes, not entire table)

Types of BGP:

eBGP: Between different ASes (external BGP)

iBGP: Within same AS (internal BGP)

Q55. What is MPLS (Multiprotocol Label Switching)? Explain its operation and advantages.
MPLS Operation:

Label Assignment: Ingress router (Label Edge Router - LER) assigns a fixed-length label (20-bit) to incoming packet based on Forwarding Equivalence Class (FEC)

Label Switching: Core routers (Label Switching Routers - LSRs) forward packet based only on label, not IP header examination

Label Swapping: At each LSR, incoming label is replaced with outgoing label (determined by MPLS routing protocol)

Label Removal: Egress router removes label and forwards based on IP address

Label Stack: Multiple labels can be pushed (stacked) for nested tunneling

Label Format:

text
0                1                2
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Label (20 bits)     | TC (3) |S|     TTL       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
Advantages:

Faster Forwarding: Label lookup O(1) vs. IP route lookup complexity

Traffic Engineering: Explicit path control; can avoid congested links

QoS Support: Labels carry QoS information; different FECs get different treatment

VPN Support: Creates secure tunnels using Label Switched Paths (LSPs)

Loop Prevention: Explicit paths prevent loops

Protocol Agnostic: Works with IPv4, IPv6, and non-IP protocols

Simplified Forwarding: Edge routers do complex routing decisions; core routers do simple label swaps

Multicast Support: Can establish LSPs for multicast groups

Applications:

Traffic engineering in ISP networks

MPLS-based VPNs (VPNs using MPLS)

Fast reroute (FRR) for link protection

Network slice creation

Q56. Compare RIP, OSPF, and BGP routing protocols.
Feature	RIP	OSPF	BGP
Type	Interior Gateway Protocol (IGP)	Interior Gateway Protocol (IGP)	Exterior Gateway Protocol (EGP)
Algorithm	Distance Vector (Bellman-Ford)	Link State (Dijkstra)	Path Vector
Metric	Hop count	Cost (bandwidth-based)	AS Path, Local Pref, MED, etc.
Hop Limit	15	Unlimited	Unlimited
Convergence Time	Slow (minutes)	Fast (seconds)	Moderate (minutes)
Scalability	Small networks only	Large internal networks	Internet scale
Memory/CPU	Very low	High	Moderate-High
Update Frequency	Periodic (30-90 sec)	Event-driven	Event-driven
Bandwidth Use	High (full table broadcast)	Moderate (incremental updates)	Moderate (incremental)
Loop Prevention	Split horizon, Poison reverse	SPF calculation	AS Path analysis
Count-to-Infinity	Yes (potential problem)	No	No
Authentication	None (RIPv2 supports)	MD5 supported	TCP session + MD5
Use Case	Legacy, very small networks	Enterprise, ISPs	Internet backbone, AS interconnection
Standards	RFC 2453	RFC 3110	RFC 4271
Deployment	Declining	Common in enterprises	Standard on Internet
Configuration	Very simple	Complex	Very complex
Summary:

RIP: Old, simple, suitable only for tiny networks (max 15 hops)

OSPF: Modern IGP, excellent for large internal networks with many routers

BGP: Essential for Internet, handles routing between thousands of autonomous systems

SECTION 7: MOBILE AD-HOC NETWORKS (MANET)
Q57. What is MANET?
MANET (Mobile Ad-Hoc Network) is a network of mobile devices that communicate wirelessly without fixed infrastructure or centralized administration. Each device (node) acts as both a host and a router, forwarding packets for other nodes. Nodes communicate directly if within range, or through intermediate nodes if out of range.​

Characteristics:

No fixed infrastructure (base stations, routers)

Dynamic topology (nodes join/leave frequently)

Limited bandwidth and power

Self-organizing and self-healing

High mobility

Multiple hops between nodes

Examples:

Military battlefield communications

Emergency response networks

Sensor networks

Vehicular networks (cars communicating)

Disaster area networks

Q58. Define AODV.
AODV (Ad-hoc On-Demand Distance Vector) is a reactive routing protocol for MANETs that discovers routes on-demand using a route request/reply mechanism.​

Key Characteristics:

Reactive (on-demand): Routes discovered only when needed

Distance vector based: Uses hop count metric

Broadcast-based: Uses flooding for route discovery

Loop-free: Sequence numbers prevent loops

Bidirectional links: Ensures symmetric links

Q59. What is DSR?
DSR (Dynamic Source Routing) is a reactive (on-demand) routing protocol for MANETs where the source specifies the complete path in each packet header.​

Key Characteristics:

Source routing: Complete path specified at source

Reactive: Routes discovered on demand

No periodic updates: Reduces overhead

Loop-free: Source specifies exact path

Route caching: Intermediate nodes cache routes

Q60. What is Mobile IP and its purpose?
Mobile IP is a protocol that allows mobile devices to maintain seamless connectivity while moving between different networks and IP subnets.​

Purpose:

Allows mobile hosts to move between networks without changing IP address

Maintains ongoing communication sessions during mobility

Provides transparent mobility to applications

Essential for cellular networks and mobile computing

Components:

Home Agent (HA): Keeps track of mobile node's location

Foreign Agent (FA): Serves mobile node in visited network

Mobile Node (MN): The moving device

Q61. Differentiate between proactive and reactive routing in MANET.
Feature	Proactive Routing	Reactive Routing
Route Discovery	Continuous, periodic	On-demand, when needed
Routing Table	Maintained for all destinations	Built only for needed routes
Control Overhead	High (periodic updates)	Low (only on demand)
Route Latency	Low (routes pre-computed)	High (delay for route discovery)
Bandwidth Use	High (regular updates)	Lower (reduces network congestion)
Memory Use	High (large routing tables)	Low (minimal entries)
Scalability	Limited (overhead increases with network size)	Better (scales better with size)
Example Protocols	OLSR, FSR, CGSR	AODV, DSR, TORA
Best For	Small, stable networks	Large, dynamic networks
Route Validity	May become stale	Current when needed
Q62. Explain AODV (Ad-hoc On-Demand Distance Vector) routing protocol with example.
**AODV Operation:​

Route Discovery:

Source broadcasts Route Request (RREQ) message

RREQ flooded through network (each node forwards once)

Destination or intermediate node with fresh route sends Route Reply (RREP)

RREP unicasted back to source along reverse path

Route Establishment:

Route Reply establishes forward path

Node stores next hop information

Sequence numbers prevent loops

Route Maintenance:

Nodes monitor link status

If link breaks, Route Error (RERR) sent to affected nodes

Route re-discovery initiated if needed

AODV Example Scenario:

Network topology:

text
S --(1)-- A --(2)-- D
 \        |  \(4)  /
  \(3)    |   \   /
   \      |    \ /
    \     |     C
     \    |
      \   |
       \(6)
        \ |
         B --(5)-- E
Source S wants to send to Destination D:

S broadcasts RREQ for D (sequence: 100)

A receives RREQ, forwards (reverse path S→A recorded)

B receives RREQ, forwards (reverse path S→B recorded)

D receives RREQ from A first, sends RREP back to A (forward path established)

A forwards RREP to S (route S→A→D established)

S can now send data via A to D

If link A-D breaks, A sends RERR to S

S re-initiates route discovery if communication needed

Advantages:

Low control overhead (routes created on demand)

Scales well for large networks

Works in dynamic topologies

Loop-free routing

Disadvantages:

Initial route discovery delay

Route request flooding can cause congestion

High latency for first packet

Memory overhead for caching routes

Q63. Describe DSR (Dynamic Source Routing) protocol.
DSR Operation:

Source Routing: Source specifies complete path in packet header

Route Discovery: Flooding-based (similar to AODV)

Source broadcasts ROUTE REQUEST

Intermediate nodes append their address to route record

Destination sends ROUTE REPLY with complete path

Route Caching: Intermediate nodes cache complete routes heard

Route Maintenance: If link breaks, source notified via ROUTE ERROR

No Route Requests to Destination: Uses cached routes from others' packets

Example Packet with Source Route:

text
Destination: 192.168.1.10
Route: Host A → Router 1 → Router 2 → Router 3 → Host 10
Advantages:

No periodic updates (pure on-demand)

Can use multiple routes to same destination

Route caching reduces discovery overhead

Simple implementation

Disadvantages:

Large packet headers (route included in every packet)

Scales poorly (large route vectors)

Single point of failure (broken link breaks entire route)

Route caching can be incorrect if topology changes

Q64. Explain Mobile IP architecture and how mobility is managed.
Mobile IP Architecture Components:

Mobile Node (MN): Device that moves between networks

Home Agent (HA): Maintains MN's home address; forwards packets to MN

Foreign Agent (FA): Provides MN services while visiting

Correspondent Node (CN): Any node communicating with MN

Mobility Management Process:

Home Network: MN operates normally with home address (HA doesn't intercept)

Entering Foreign Network:

MN receives Care-of Address (CoA) from FA in foreign network

MN registers CoA with Home Agent (via registration request)

HA creates binding: Home Address ↔ Care-of Address

Data Reception While Mobile:

CN sends packets to MN's home address (as usual)

HA intercepts packets destined for MN

HA encapsulates packets and tunnels to CoA (FA)

FA decapsulates and delivers to MN

MN receives packet with original home address

Data Transmission by MN:

MN uses home address as source (reverse tunnel to HA)

Or sends directly using CoA

Route Optimization (optional):

CN learns MN's CoA directly

CN can tunnel directly to CoA (bypasses HA)

Mobility Process Diagram:

text
Mobile Node in Home Network:
CN →IP: 192.168.1.100→ HA →IP: 192.168.1.100→ MN

Mobile Node in Foreign Network:
CN →IP: 192.168.1.100→ HA →tunnel→ FA →IP: 10.0.0.50→ MN
(MN's CoA = 10.0.0.50)
Types of Mobility:

Macro-mobility: Changing networks (requires Mobile IP)

Micro-mobility: Within same network (handoff)

Q65. Compare AODV, DSR, and Mobile IP based on performance and control overhead.
Aspect	AODV	DSR	Mobile IP
Type	MANET routing	MANET routing	Mobility management
Route Discovery	Flooding (RREQ)	Flooding (ROUTE REQUEST)	HA/FA registration
Control Overhead	Moderate	Low (route caching reduces)	Low (only registration changes)
Packet Headers	Small (no full route)	Large (full route per packet)	Modified tunnel headers
Scalability	Good for medium networks	Poor (large headers)	Good for any network size
Route Optimality	Good (distance vector)	Excellent (complete path control)	Good (if route optimized)
Latency	Moderate	Moderate	Low (no tunneling overhead)
Memory Use	Moderate (routing tables + cache)	Higher (route caching)	Low (binding table)
Mobility Support	Limited (assumes slow mobility)	Limited	Excellent
Performance in Large Networks	Better	Degrades	Excellent
Performance in Dense Networks	Good	Poor (packet overhead)	Good
Suitable For	Ad-hoc networks, sensor nets	Smaller mobile networks	Cellular networks, mobility
Q66. Discuss the challenges in MANET routing.
Key Challenges:

Dynamic Topology:

Nodes constantly join/leave/move

Links appear/disappear frequently

Routing tables become stale quickly

Challenge: Frequent route re-computation

Limited Bandwidth:

Wireless medium has limited capacity

Routing overhead consumes precious bandwidth

Challenge: Minimize control messages while maintaining connectivity

Power Constraints:

Mobile devices run on batteries

Routing protocol must be energy-efficient

Challenge: Reduce computational load and minimize transmission

Unidirectional Links:

Wireless links may be asymmetric

A may hear B but B cannot hear A

Challenge: Ensure bidirectional communication

Scalability:

Network may grow from tens to hundreds of nodes

Flooding-based discovery doesn't scale

Challenge: Design protocols for large-scale networks

Route Maintenance:

Broken links require route repair

Multiple failures in unstable networks

Challenge: Quickly detect failures and find alternatives

Interference and Fading:

Wireless propagation affected by obstacles

Radio interference from other devices

Link quality varies with time

Challenge: Predict link failures accurately

Network Partitioning:

Network may split into disconnected components

Routes through partition become invalid

Challenge: Detect partition and notify affected nodes

Limited Processing Power:

Mobile devices have limited CPU

Complex routing algorithms not feasible

Challenge: Design simple yet effective protocols

Security:

Open wireless medium vulnerable to attacks

Malicious nodes can disrupt routing

Challenge: Secure routing without excessive overhead

Mobility Prediction:

Unpredictable node movement in random mobility

Route quality depends on node velocity

Challenge: Predict mobility patterns for route stability

Quality of Service (QoS):

No guaranteed bandwidth or latency

Bursty traffic patterns

Challenge: Provide QoS guarantees in variable network

KEY TAKEAWAYS FOR NETWORK LAYER
Network Layer Functions: Logical addressing, routing, forwarding, fragmentation/reassembly

Switching Techniques: Circuit (dedicated path), Message (store-forward), Packet (individual packets)

IP Addressing: IPv4 (32-bit), IPv6 (128-bit), CIDR improves efficiency

Routing: Static (manual) vs Dynamic (automatic), Distance Vector vs Link State algorithms

Protocols: ARP (IP↔MAC), ICMP (errors), IGMP (multicast), RARP (MAC↔IP, obsolete)

Routing Protocols: RIP (simple, limited), OSPF (large networks), BGP (Internet backbone)

Mobile Networks: AODV (on-demand), DSR (source routing), Mobile IP (seamless mobility)
